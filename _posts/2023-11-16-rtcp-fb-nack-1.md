---
layout: post
title: rtcp 如何设计nack
date: 2023-11-16 20:10:00 +0800
author: Fisher
pin: True
meta: Post
categories: webrtc nack rtcp
---


* content
{:toc}

---


## 1. 接收方如何判断数据包是否丢失 

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/nack-1.jpg)

解决方案：编号，每一个 packet 都打上一个序列号（Seq number），接收端发现序列号跳变/缺失，则可以判断数据包丢失了。
这就是为什么 TCP 协议的包头（packet header）里面要定义一个序列号字段的原因（如图红色标记）：

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/tcp.webp)

扩展一下，我们再看看 UDP 协议的包头（packet header）的定义：

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/udp.webp)

可以看到，UDP header 没有用任何字段来标识序列号（Seq number），由此可见，UDP 是一个完全不关心是否丢包的传输协议。



## 2. 发送方如何确认数据包已经丢失

### 2.1 ~~停等协议~~

发送方每次只发送一个包，同时启动一个定时器。如果定时器超时依然没有收到这个包的 ACK，则认为丢包，重传这个包。如果收到 ACK，则重置定时器并发送下一个包。

**问题：丢包的判断和传输效率非常低。**

### 2.2 ~~连续 ARQ 协议 & 滑窗协议~~

发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有包可以连续发送出去，中途不需要依次等待对方的 ACK 确认。

接收方通常采用 **积累确认模式**，即不必对每一个包逐个发送 ACK，而是在连续收到几个包后，对顺序到达的最后一个包序号发送 ACK，表示：这个包及之前的所有包都已正确收到了。

**积累确认模式的缺点**：乱序比较严重的网络下，效率非常低，部分已经送到但没有按照顺序送达的包也必须重传。

改进方案：选择性重传（注：KCP/SRT 协议有实现）：对于顺序的包，发送积累确认；跳跃的包，发送 ACK；发送端只重传真正丢失的数据包。

### 2.3 ~~???快速重传~~

使用 ACK 机制的传输协议，通常在发送端等到某个数据包的 ACK 超时后，才会重传数据包，不够及时。

快速重传：如果接收端接收到了序号跳跃的数据包，则立即给发送方发送最后一个连续的数据包的 ACK（重复确认） 。如果发送端收到连续 3 个重复确认，则认为该 ACK 的下一个数据包丢失了，并立即重传该丢失的数据包。

### 2.4 !!! NACK

接收方定时把所有未收到的包序号通过反馈报文通知到发送方进行重传。
带来的改进：**减少的反馈包的频率和带宽占用，同时也能比较及时地通知发送方进行丢包重传**。



## 3. ??? 多久算重传超时

RTO：重传超时时间（Retransmission Timeout），它是发送端用来判断数据包丢失和执行重传的最重要的一个参数。

很明显，它应该是一个随网络传输的 RTT（往返时间）而变化的值，理想情况下，RTO 的值不小于 RTT 即可（从数据包发送到对方的 ACK 到达的最短时间），实际情况下，RTT 变化是非常频繁的，每一次传输的 RTT 可能都不一样，如果粗暴地设置 RTO = RTT 则一定会导致重传过度频繁。

因此 TCP 协议采用的 RTO 计算方法是：

> 1. 基于多次 RTT 测量，给出一个平滑后的 RTT 预估值：SRTT（Smoothed Round Trip Time）
> 2. RTO = SRTT + 某种系数（防止抖动的阈值）
> 3. 进一步，系统级别设置 RTO 的下限为 100ms 或 200ms，防止异常值
> 4. 更进一步，对于重传包的 RTO，加上一个退避算法，比如，每重传一次，则 RTO = 2 RTO 这样的方式来减少对一个包进行频繁的重传

注：关于重传包 RTO 的退避策略，KCP 经过实验证明 ，RTO 的退避系数使用 1.5 倍的效果比 2 倍的效果更好。



## 4. 发送方的数据包要缓存多久

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/n.webp)

发送端为了能实现重传，必须在本地将发送的数据包缓存起来，在需要重传的时候，即可从缓存队列里面取到该数据包进行重传。
对于 ACK 模型的传输协议（如：TCP），在收到对方的 ACK 之后删除缓存即可，那如果是 NACK 模型的传输协议，如何更新和清理这个缓存队列呢 ？

### 4.1 基于 RTT 和 NACK 时间间隔

假设当前的 RTT（网络往返时间）是 rtt ms，NACK 的反馈时间间隔是 x ms，那么，一个数据包在发送缓存队列中最少的存活时间应该是：

```less
cache time = 2 * rtt + x
```

假设在这个时间后内收到的 NACK 反馈包没有指出该数据包丢失，则可以删除了。当然，类似 RTO 所涉及到的问题原因，rtt 是频繁变化的，因此单纯依靠这个理论值来删除缓存并不安全，建议增加一定的冗余。

### 4.2 方基于业务场景

对于实时音视频通信场景，对延时有一定的要求，因此，超过 1s 的数据，就没有必要再重传了。或者，假设视频的 GOP 是 2s，那么，最多在缓存队列保持 2s 的数据包即可。



## 5. ??? 接收端多久发送一次 nack 请求 ？？

1. 假设接收端发现数据包发生序列号跳跃后立即发送 NACK 请求
2. 在1存在一定的冗余，由于 UDP 数据包可能会乱序到达，因此这种方案会导致过多的无效重传请求。 这时候还需要配合方案2，就是**每间隔指定的时间（比如：WebRTC 使用的是 10ms）发送一次 NACK 请求，一次性带上这段时间所有的丢包序号。**
3. webrtc，有两种发送方式，一种是方案一，安序号来判断是否丢包，而发送请求，有且仅发送一次；方案二就是如果第一次按序号请求失败了，则按一定的时间间隔，发送请求。



## 6. 哪些丢失的数据包会放入 nack 请求队列中

接收端的重传请求的队列也应该有一定的机制，不是所有的丢包都必须要求重传，

> 1. **当前音频播放到了 timestamp 为 x 的时间点了，其实在 timestamp < x 的所有丢失的音频包都不应该再请求重传了，视频也是如此。**
> 2. **作为 SFU 中转服务器，它没有播放时间的概念，因此方法 1 并不适用，但是可以参考发送端缓存的逻辑，假设 GOP 是 2s，则对比最新的 packet 时间戳，丢失的数据包时间在 2s 之前的数据，则没有必要再申请重传了。**



补充一点，作为 SFU 中转服务器，可能会遇到下述情况，即：**收到客户端的 NACK 请求的数据包不再自己的 cached packet list 里面**：

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/sfu-nack.webp)

- SFU 作为的接收端，发现丢包也跟普通的接收端一样，定时主动地向源头发送 NACK 请求；
- SFU 作为发送端，收到 NACK 请求后，如果发现不在 cached list，则标记一下，一旦收到源头的重传，则第一时间转发到下行。
- 上图中，红色的就是丢失丢失的包，发起nack请求；
  



## 7. 重传失败，需要一直重传？重传失败后的nack请求频率

- 重传请求的最大次数（10次）
- 两次重传请求之间的间隔（5 + RTT * 1.5）
- 重传请求的队列最大数（1000）

> 1. 当一个丢失的包被 NACK 请求重传了至少 N 次（如：10次）后依然没有成功收到，则应该放弃了（很可能发送端也已经没有这个数据包的缓存了）。
> 2. 考虑到重传请求在发送端的响应时间及网络 RTT，接收端应该确保在一定时间周期内不要频繁地发送对同一个数据包的 NACK 重传请求。（如：WebRTC 选择的时间周期是 5 + RTT * 1.5），即：在这个时间周期内不再重复发送同一个数据包的 NACK 请求。
> 3. 当 nack reqeust list 里面的数据包太多了（比如：超过 1000），则应该考虑清理一下（网络太弱了），对于视频的话，直接发送 IDR request，重新申请新的 GOP 数据。



## 8. 重传包的优先级？FEC 包是否需要重传

考虑到丢包 -> 重传已经耽误了数据包的达到时间了，因此，**重传包的优先级应该大于普通的数据包，当然，也应该有根据重传次数优先级逐步递减的策略**。
FEC 包不需要，意义不大，FEC 的目的是为了减少重传而增加的冗余包，丢掉没有致命的影响，我们只需要重传价值更大的数据包即可。



## 9. RTCP 协议的 NACK 报文

NACK 报文的定义在 [[rfc4585\]](https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc4585) 文档中定义。

RTCP 的反馈报文包头定义如下，FMT 和 PT 决定了该报文的类型，FCI 则是该类型报文的具体负载：

![img]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/nack-reprort.webp)

协议规定的 NACK 反馈报文的 PT= 205，FMT=1，FCI 的格式如下（可以附带多个 FCI，通过 header 的 length 字段来标示其长度）：

```less
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            PID                |             BLP               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

这里的设计比较巧妙，它可以一次性携带多个连续的数据包的丢包情况：

- PID（Packet identifier），即为丢失的 RTP 数据包的序列号
- BLP（Bitmao of Lost Packets），通过掩码的方式指出了接下来 16 个数据包的丢失情况



## 10. !10、20、100、1000、10000

NACK 模块具体的发送策略围绕着 10、20、100、1000、10000 这五个数字展开。

```cpp
const int kMaxNackRetries = 10;
const int kDefaultRttMs = 100;
const int kProcessIntervalMs = 20;
const int kMaxNackPackets = 1000; 
const int kMaxPacketAge = 10000;
```

### 10.1 同一个包的 接收端 最大nack请求次数，10 次

NACK 模块对同一包号的最大请求次数，超过这个最大次数限制，会把该包号移出 nack_list，放弃对该包的重传请求。


### 10.2 批量定时重发nack请求，20 毫秒，非固定

NACK 模块每隔 20 毫秒批量处理 nack_list，获取一批请求包号存储到 nack_batch，生成 nack 包并发送。
不过，nack_list 的处理周期并不是固定的 20ms ，而是基于 20ms 动态变化。
？

### 10.3 同一个包的重传请求的时间间隔不能小于rtt，100 毫秒

NACK 模块默认 rtt 时间，如果距离上次 nack 发送时间不到一个 rtt 时间，那么不会发送 nack 请求。

从发送 nack 请求到接收重传包一般是一个 rtt 的时间，也就是说重传包理论上应该在一个 rtt 时间内到来，超过这个时间还未到来，才会发送 nack 请求。

> **注意**，100ms 只是 rtt 的默认值，在实际应用中，**rtt 应该要根据网络状况动态计算**，计算方式有很多种，比如对于接收端来说，可以通过发送 xr 包来计算 rtt。



### 10.4 !重传请求的最大数量，1000 个（丢失包数量）

nack_list 的最大长度，即**本次发送的 nack 包至多可以对 1000 个丢失的包进行重传请求**。

如果丢失的包数量超过 1000，会循环清空 nack_list 中关键帧之前的包，直到其长度小于 1000。也就是说，放弃对关键帧首包之前的包的重传请求，直接而快速的以关键帧首包之后的包号作为重传请求的开始。



#### 10.4.1 NACK 关键帧清空策略 

假设连续收到了包号为 0、981、1182 的三个包，且都为**关键帧的首包**。当收到包号为 981 的包时，可知丢失了 980 个包，当收到包号为 1182 的包时，丢失的包数量达到 980 + 200，已经超过 1000，这时，需要控制 nack_list 的长度，如何处理？

1. 从 `key_frame_list` 找到第一个关键帧包号 0，对应到 `nack_list`的 1 号包，清空` nack_list` 1 号包之前的包，发现 1 号包是起始包，前面没有数据，本次清空操作失败。
2. 继续找到 `key_frame_list` 下一个关键帧包号 981，对应到 `nack_list` 的 982 号包，清空 `nack_list ` 的982 号包之前的包，1 号包到 980 号包被删除，此时 nack_list 长度为 200，小于 1000，结束清空操作。

整个过程如下图所示：

![图片]({{ site.url }}{{ site.baseurl }}/images/rtcp-fb-nack-1.assets/key-frame-nack.png)

>  **如果经过多轮清空操作，key_frame_list 中已经没有关键帧（无法再去清空 nack_list 中关键帧之前的包），但是此时 nack_list 的长度仍然大于 1000，那么将清空整个 nack_list，放弃所有重传请求，直接请求新的关键帧**。
>
> 一旦发生这种情况，基本可以说明当前网络环境很差，从而导致大量的丢包。如果继续期待 nack 重传，那么可能会因为长时间等待重传包而导致画面卡顿，或者因为获取不到重传包而导致解码花屏。
>
> 因为关键帧可以单独解码出图像，不必参考前后视频帧，所以，为了使解码端能够立刻刷新出新图像，此时采取请求关键帧的方式替代重传数据包，是更加合理且高效的做法。



### 10.5 包号跨度，10000 个

nack_list 中包号的距离不能超过 10000 个包号。即 nack_list 中的包号始终保持 `[cur_seq_num - 10000, cur_seq_num]` 这样的跨度，以保证 nack 请求列表中不会有太老旧的包号。**例如服务器上行推流链路出现长时间抖动，恢复后导致接收端 rtp 包号断层。**

### 10.6 !小结

10.1 和策略 1 属于 nack 包发送的保护策略，比如有以下两种场景：

#### 场景 1

服务器下行分发链路丢包率过高。

这会导致接收端对一些包的重传请求次数过高，如果不对 nack 请求次数做限制，那么接收端将无限循环发送 nack 请求。

#### 场景 2

**服务器上行推流链路出现长时间抖动，恢复后导致接收端 rtp 包号断层。**

假如包号断层达到 1 万，那么在抖动恢复的瞬间，接收端会将 1 万个包号全部加入到 nack_list 。这会增加服务器生成 nack 包的负担，而且生成的 nack 包将达到 2.3KB 大小，推流端解析这个包同样也要耗费更多时间。

所以，如果没有 10.1、10.4 这两条 nack 保护策略，那么，当拉流用户很多的时候，上述两种场景会给服务器和端带来巨大的 cpu 性能损耗，并会引起 nack 网络风暴。不过，即使有这两条发送保护策略加持，有时还是会产生很多问题，比如下面这种场景。

#### 场景 3

上游服务器上行推流链路丢包，引发下游服务器回源分发链路丢包。

**存在这种情况：上游服务器发送 nack 请求后，rtx 重传包还未到来，所以还未中继分发到下游服务器，然而此时下游服务已经收到了下游用户连续的并发的 nack 请求。针对这种场景，则需要对上行推流链路进行数据包排序，只有组成完整的帧才会中继分发到下游服务器，这样就避免了下游用户并发的 nack 请求。**

**其实，nack 的发送保护策略还有一条：收到一组连续且完整的帧之后，会立即对 nack_list 执行部分清空操作，避免无必要的再次重传请求。**

**最后，根据10.1 和 10.3 的描述，我们可以推断出这样的结论：假设当前网络 rtt 为 100ms，那么 100ms * 10 次，恰好为 1s。也就是说，包在 1s 内还没有重传回来，那么就放弃它。**



## 参考

1. [谈谈网络通信中的 ACK、NACK 和 REX](https://zhuanlan.zhihu.com/p/104322256)
2. [WebRTC QoS | NACK 格式与发送策略](https://mp.weixin.qq.com/s?__biz=MzU3MTUyNDUzMA==&mid=2247484047&idx=1&sn=fd67a143efd8c9dfd92811b9e2d50d5d&chksm=fcdf9652cba81f44b29b5e0ab5494334291af57ea604faf98722855eec4962faf79da937fdac&scene=178&cur_album_id=1345116764509929473#rd)